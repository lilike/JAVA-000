 # Week04作业



# 01 题目1

思考有多少种方式，在 main 函数启动一个新线程，运行一个方法，拿到这个方法的返回值后，退出主线程？
写出你的方法，越多越好，提交到 Github



方法一: 使用CountDownLatch,主线程Await,等到新线程执行结束后,进行countDown操作,就可以推出主线程了

方法二: 使用FutureTask返回一个Future,然后使用future的get方法,会进行阻塞直到获取到结果

方法三: 主线程进行调用新线程的join方法,就可以等到新线程执行完成后执行主线程.

方法四: 使用CyclicBarrier让主线程和新线程相互等待.

方法五: 新线程调用的方法有一把锁,让主线程去获取这把锁,新线程执行完成后,主线程才会进行运行状态



# 02 列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点

1. CountDownLatch 实现线程等待

就是主线程需要等待多个线程执行完成之后做一些操作的时候使用.

老板把工作任务分配给不同的小弟去做,最后老板把小弟的工作成果进行汇总的时候使用.

优点: 使用场景比较丰富

缺点: 不可以重用,再次使用需要初始化计数器的值.



2. cyclicBarrier

就是多个线程之间相互等待.

和抱旅游团,团长等待所有游客不同,驴友之间是相互等待,然后一起出去玩.

cyclibarrier可以指定一个回调函数,调用回调函数的是这些线程之间的最后一个运行完成的线程.

所以回调函数里面尽量使用异步的方式.



3. ReadWriteLock

读写锁: 可以分为读锁和写锁.

读锁不能升级为写锁.但是写锁可以降级为读锁.

优点是读写分离.提高了性能



4. Lock和Condition

Lock是一个显示的锁.相比于synchronized更加实用

condition的方法和obj锁对象的wait和notify有着类似的效果.

Lock和Condition让程序员使用锁更加的清晰明了.



5. CopyOnWriteArrayList 

是一个读和写复制的线程安全的ArrayList

写的时候直接复制一份副本去写,不会影响到旧引用.

然后替换旧引用.



6. ConcurrentHashMap 

Jdk1.7采用分段的segment,这样的话就把锁的粒度变小了,同步阻塞的概率降低了.

jdk1.8采用cas技术实现的.

是一个线程安全的HashMap



7. ThreadLocal

线程本地变量,每一个线程对应的本地变量不同.

注意的是要线程退出前一定要清理,不然会引发OOM的危险

可以用来隐式传参.



# 03 什么是并发? 什么是高并发? 实现高并发可用系统需要考虑哪些因素,对于这些你是怎么理解的?

并发就是多核CPU时代的产物,就是多个线程同时访问某个资源.

高并发就是大量的线程在同一时间访问共享的资源.

高并发需要考虑的是线程安全问题,锁的性能问题,吞吐量,延迟,系统资源与请求之间的平衡.

比如在分布式环境下,为了保证线程安全,需要使用分布式的锁.

这就是跨JVM进程的锁.





